/* Generated by re2c 1.0.1 on Thu Nov 22 14:23:45 2018 */
#line 1 "mytest.l"
/* re2c -t mytest.def.h -c -o mytest.lex.c mytest.l */

#include <stdio.h>
#include "mytest.def.h"
#include "mytest.l.h"
#include "mytest.tab.h"

mytest_lex_global scanner_globals;

#define YYCTYPE char
#define YYFILL(n)
#define STATE(name)  yyc##name
#define BEGIN(state) YYSETCONDITION(STATE(state))
#define MYTEST_SCNG(v) (scanner_globals.v)

#define YYGETCONDITION()  MYTEST_SCNG(yy_state)
#define YYSETCONDITION(s) MYTEST_SCNG(yy_state) = s
#define YYCURSOR  MYTEST_SCNG(yy_cursor)
#define YYLIMIT   MYTEST_SCNG(yy_limit)
#define YYMARKER  MYTEST_SCNG(yy_marker)

//以下T_*(token终结符)由语法分析器定义
int mytest_scan(lex_param * lex){
    //lex词法分析时附带数据可以放到  lex中,供后面语法分析使用
    
#line 29 "mytest.lex.c"
{
	YYCTYPE yych;
	switch (YYGETCONDITION()) {
	case yycINITIAL: goto yyc_INITIAL;
	case yycST_IN_SCRIPTING: goto yyc_ST_IN_SCRIPTING;
	}
/* *********************************** */
yyc_INITIAL:
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	switch (yych) {
	case '<':	goto yy5;
	default:	goto yy3;
	}
yy3:
	++YYCURSOR;
yy4:
#line 50 "mytest.l"
	{
        if (YYCURSOR > YYLIMIT) {
            return END;
        }
        return T_INPUT_ERROR;
      }
#line 54 "mytest.lex.c"
yy5:
	yych = *++YYCURSOR;
	switch (yych) {
	case '?':	goto yy6;
	default:	goto yy4;
	}
yy6:
	++YYCURSOR;
#line 30 "mytest.l"
	{
        //进入 ST_IN_SCRIPTING
        //前面<XXX>类似分组块
        BEGIN(ST_IN_SCRIPTING); return T_BEGIN;
      }
#line 69 "mytest.lex.c"
/* *********************************** */
yyc_ST_IN_SCRIPTING:
	if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case '\r':
	case ' ':	goto yy12;
	case '\n':	goto yy15;
	case '*':	goto yy18;
	case '+':	goto yy20;
	case '-':	goto yy22;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy24;
	case '?':	goto yy27;
	case '\\':	goto yy28;
	case 'e':	goto yy30;
	default:	goto yy10;
	}
yy10:
	++YYCURSOR;
yy11:
#line 44 "mytest.l"
	{
        if (YYCURSOR > YYLIMIT) {
            return END;
        }
        return T_UNKNOWN;
      }
#line 107 "mytest.lex.c"
yy12:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case '\r':
	case ' ':	goto yy12;
	default:	goto yy14;
	}
yy14:
#line 40 "mytest.l"
	{return T_WHITESPACE;}
#line 121 "mytest.lex.c"
yy15:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy15;
	default:	goto yy17;
	}
yy17:
#line 41 "mytest.l"
	{return T_BR;}
#line 133 "mytest.lex.c"
yy18:
	++YYCURSOR;
#line 38 "mytest.l"
	{return T_OPTAG_XDD;}
#line 138 "mytest.lex.c"
yy20:
	++YYCURSOR;
#line 36 "mytest.l"
	{return T_OPTAG_ADD;}
#line 143 "mytest.lex.c"
yy22:
	++YYCURSOR;
#line 37 "mytest.l"
	{return T_OPTAG_DEC;}
#line 148 "mytest.lex.c"
yy24:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy24;
	default:	goto yy26;
	}
yy26:
#line 35 "mytest.l"
	{return T_NUMBER;}
#line 169 "mytest.lex.c"
yy27:
	yych = *++YYCURSOR;
	switch (yych) {
	case '>':	goto yy31;
	default:	goto yy11;
	}
yy28:
	++YYCURSOR;
#line 39 "mytest.l"
	{return T_OPTAG_MOD;}
#line 180 "mytest.lex.c"
yy30:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'x':	goto yy33;
	default:	goto yy11;
	}
yy31:
	++YYCURSOR;
#line 43 "mytest.l"
	{return T_END;}
#line 191 "mytest.lex.c"
yy33:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'i':	goto yy35;
	default:	goto yy34;
	}
yy34:
	YYCURSOR = YYMARKER;
	goto yy11;
yy35:
	yych = *++YYCURSOR;
	switch (yych) {
	case 't':	goto yy36;
	default:	goto yy34;
	}
yy36:
	++YYCURSOR;
#line 42 "mytest.l"
	{ return T_EXIT; }
#line 211 "mytest.lex.c"
}
#line 56 "mytest.l"

}



void mytest_scan_start(char * parser,int len){
    BEGIN(INITIAL);//开始进入
    YYCURSOR = parser;
    YYLIMIT=parser+len;
}


